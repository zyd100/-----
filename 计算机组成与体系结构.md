[TOC]


### 一：数的表示

#### 1：R进制转十进制：按权展开法

拆分每个位置上的数，即每个位置的数和其权相乘。

将R进制的每一位数值使用$R^k$，即幂的底数是R，指数为k

#### 2：原码

+ 最高位为符号位

+ 对于正数而言，符号位为0
+ 对于负数而言，符号位为1

```
正1：00000001
负1：10000001

则1+（-1） = 00000001
     	    10000001
     	 ----------------
     	 	10000010
     	  = -2
```



#### 3：反码

+ 正数的反码为原码
+ 负数的反码为符号位不变，其它位在原码的基础上取反



#### 4：补码

+ 正数的补码为原码
+ 负数的补码是在反码的基础上加1

+ 计算机做运算使用的是补码

#### 5：移码

+ 主要用于在浮点运算中做
+ 在补码的基础上把首位（符号位）取反

#### 6：数值表示范围

|      | 二进制         | 整数 |
| ---- | -------------- | ---- |
| 原码 | 1111111-0111111 | $$-\left(2^{n-1} - 1\right)$$ ~ $2^{n-1}-1$  即 -127  ~ 127 |
| 反码 | 11111111-01111111 | $$-\left(2^{n-1} - 1 \right)$$ ~ $2^{n-1}-1$  即 -127  ~ 127 |
| 补码 | 10000000-0111111 | $$-\left(2^{n-1}\right)$$ ~ $2^{n-1}-1$  即 -128  ~ 127 |



#### 7：浮点数运算

+ 浮点数表示

  $N = M * R^e$

  其中M称为尾数，e是指数，R为基数

+ 浮点数运算步骤

  $$对阶\implies尾数运算\implies结果格式化$$

  $$1000 = 1.0 * 10^3$$

   $$119 = 1.19 * 10^2$$


  ```
  一般对阶时，将低的阶向高阶转换。
  结果格式化时，尾数的第一位（即小数点左侧的位）不可以是0，也不可以大于1位
  ```

### 二：数制转换
#### 8：进制转换（短除法）

+ 十进制转R进制使用短除法

  ```
  R|94		余0
  2|47		余1
  2|23		余1
  2|11		余1
  2|5 		余1
  2|2			余0
  2|1			余1
  2|0
  
  逆序取余数	1011110
  ```

### 三：计算机组成

#### 9：CPU结构

##### 9.1、运算器

+ 算术逻辑单元ALU

+ 累加寄存器AC

  通用的寄存器。

+ 数据缓冲寄存器DR

  用于暂存数据。

+ 状态条件寄存器PSW

  用来存储在运算过程中相关的标志位，如进位、溢出和中断。

##### 9.2、控制器

+ 程序计数器PC
+ 指令计算器IR
+ 指令译码器
+ 时序部件

#### 10：Flynn（体系结构）

| 体系结构类型       | 结构                                     | 关键特性                               | 代表                                   |
| ------------------ | ---------------------------------------- | -------------------------------------- | -------------------------------------- |
| 单指令单数据流SISD | 控制部分一个；处理器一个；主存模块一个； |                                        | 单处理器系统                           |
| 单指令多数据流SIMD | 控制部分一个；处理器多个；主存模块多个； | 各处理器以异步的形式处理同一个指令     | 并行处理机，阵列处理机，超级向量处理机 |
| 多指令单数据流MISD | 控制部分多个；处理器一个；主存模块一个； | 被证明不可能，至少是不实际             | 目前没有                               |
| 多指令多数据流MIMD | 控制部分多个；处理器多个；主存模块多个； | 能够实现作业，任务，指令等各级全面并行 | 多处理机系统                           |

#### 11：CISC（复杂指令系统）

| 指令系统类型 | 指令                               | 寻址方式 | 实现方式               | 其他       |
| ------------ | ---------------------------------- | -------- | ---------------------- | ---------- |
| CISC（复杂） | 数量多，使用频率差别大，可变长格式 | 支持多种 | 微程序控制技术（微码） | 研制周期长 |



#### 12：RISC（精简指令系统）

| 指令系统类型 | 指令                                                         | 寻址方式   | 实现方式                                               | 其他                       |
| ------------ | ------------------------------------------------------------ | ---------- | ------------------------------------------------------ | -------------------------- |
| RISC（精简） | 数量少，使用频率接近。定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 | 支持方式少 | 增加了通用寄存器；硬布线控制逻辑为主，适合采用流水线。 | 优化编译，有效支持高级语言 |



#### 13：流水线
##### 13.1、基本概念
> 流水线是指程序执行时，多条指令重叠进行操作的一种准并行实现处理技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。

##### 13.2、周期及流水线执行时间

$取指\implies分析\implies执行$

+ 流水线周期

  ```
  执行时间最长的一段
  ```

+ 流水线计算公式

  ```
  一条指令执行时间 + （指令条数 - 1 ） * 流水线周期
  考试时优先使用理论公式，没有符合的答案，则使用实践公式
  ```

  + 理论公式（tk表示每个段占用的时间）

    $(t1+t2+\ldots+tk)+(n-1)*\Delta t$

  + 实践公式（把每个段执行时间都看作周期时间，其中k表示有几个段）

    $(k + n-1)*\Delta t$
    
  + K为完成一条指令需要的步骤。设完成一条指令需要取指，分析，执行三个步骤。则K=3
  
    



##### 吞吐率

> 指在单位时间内流水线所完成的任务数量或输出的结果数量。

+ 吞吐率公式

  $TP = \frac{指令条数}{流水线执行时间}$

+ 最大吞吐率公式（理想状态的情况）

  $TP_{max} = \lim_{n \to \infty} \frac{n}{k + n -1} = \frac{1}{\Delta t} $

##### 加速比

> 完成同一批任务，不使用流水线和使用流水线时间的比值。加速比越高越好。

+ 加速比公式

  $S = \frac{不使用流水线执行时间}{使用流水线时间}$

  

##### 效率

> 流水线的效率是指流水线的设备利用率，在时空图上，流水线的效率定义为n个任务占用的时空区与k个流水段总的时空区之比。

+ 流水线效率公式

  $E = \frac{n个任务占用的时空区}{k个流水段总的时空区} = \frac{T_n}{KT_k}$

##### 例题1（流水线）

```
若指令流水线把一条指令分为取指、分析和执行三部分，且三部分执行时间分别为2ns，2ns，1ns。
那么，
流水线的周期是多少？
100条指令执行完毕需要多长时间？
吞吐率是多少？
最大吞吐率是多少？
加速比是多少？
效率多少？

答：
流水线周期为2ns。
100条指令执行完毕需要时间= 流水线建立时间 + （n-1）* 流水线周期时间 = 5 + （99）*2 = 203ns
吞吐率 = 100/203ns
最大吞吐率 = 1/2
加速比 = （2+2+1）*100/203=500/203
效率=（2+2+1）*100/3*（5+99*2）=500/609
```



### 四：存储系统

#### 14：计算机存储

##### 14.1、Cache

> 工作于CPU和存储器之间，主要用于提高CPU输入输出的速率

##### 14.2、时间局部性和空间局部性

- 时间局部性：被引用过一次的存储器位置在未来会被多次引用（通常在循环中）
- 空间局部性： 如果一个存储器的位置被引用，那么将来他附近的位置也会被引用

##### 14.3、随机存储器和只读存储器

+ 随机存取存储器 RAM（掉电后数据丢失）

  + DRAM（Dynamic RAM，动态）
  + SRAM （Static RAM,静态）
  
+ 只读存储器 ROM（断电后不会丢失信息）

  + MROM（Mask ROM，掩模式存储器）
  + PROM （Programmable ROM 一次可编程 ROM）
  + EPROM（Erasable PROM 可擦除的PROM）
  + 闪速存储器（flash memory，闪存）
  
##### 14.4、命中率计算


#### 15：磁盘工作原理

+ 磁盘结构

  + 磁道
  + 扇区

+ 存取时间

  存取时间 = 寻道时间 + 等待时间（平均定位时间  + 转动延迟）

  > 寻道时间：磁头移动到磁道所需的时间
  >
  > 等待时间：等待读写的扇区转到磁头下方所用的时间






##### 例题1（主存储器编址）

```
内存地址从AC000H到C7FFFH，共有（1）K个地址单元，如果该内存地址按字（16bit）编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每个存储单元存储（2）位。

（1）：大地址 - 小地址  + 1 = C7FFF-AC000 + 1 = (C7FFF + 1) - AC000 = C8000 - AC000 = 1C000H
 问共有多少K，则1处应等于 1C000 / 2的10次方 = 112
（2）112K * 16 = 28 * 16 * X 则X = 4
```

> tips: 16进制的加减法进/借位规则：借一当十六，逢十六进一
>
> 1C000 / 2的10次方 = 112计算步骤：先1C000转10进制=1\*16的4次方+12\*16的3次方。∵16的4次方=2的16次方，同理16的三次方=2的12次方，此时1C000 / 2的10次方即可转为2的16次方+12\*2的12次方/2的10次方，约去分母得 2的6次方+12\*2的2次方=112
>
> 



##### 例题2（磁盘读取资源）

```
假设某磁盘的每个磁道划分位11个物理块，每块存放1个逻辑记录，逻辑记录R0,R1....R9,R10存放在同一个磁道上，记录的存放顺序如下表所示
```

| 物理块   | 1     | 2     | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 逻辑记录 | $R_0$ | $R_1$ |  $R_2$    |   $R_3$   |  $R_4$   |  $R_5$    |   $R_6$   |   $R_7$   |  $R_8$    |  $R_9$    | $R_{10}$     |

```
如果磁盘的旋转周期为33ms，磁头当前处在R0的开始处，若系统使用单缓冲区顺序处理这些记录，每个记录的处理时间为3ms。
则处理这11个记录的最长时间为 （1）？
若对信息存储进行优化分布后，处理11个记录的最少时间为（2）？

（1）由题意知，读取一个逻辑记录的时间为3ms,且系统使用的是单缓冲区，且处理一个记录的时间为3ms。所以完整的处理一个记录的时间为 3 + 3 = 6ms。(33ms一个旋转周期，11个物理块，及读取一个逻辑记录的时间为3ms)
	同时，由于数据是顺序存取的，在处理缓冲区数据的时候，顺序的下一个逻辑块已经旋转过去了，所以要处理下一个逻辑块的数据，需要到达数据的开始，即需要磁盘转动10个逻辑块，即30ms。
	所以需要的处理时间为 6 * 11 + 30 * 10 = 366ms
（2）最优的条件即处理完当前数据时，下一个顺序数据就转到了磁头下面，同时由于系统使用单缓冲区，所以每个记录完整的处理时间都是6ms。
	所以最少的处理时间为 6 * 11 = 66ms
```




### 五：输入输出
#### 16：计算机总线

+ 内部总线

+ 系统总线

  + 数据总线

    > 用于传输数据。计算机所说的32位，64位，意义即是计算机的一个字为32bit位或64位。即计算机一次最多可以传输32或64bit位数据。

  + 地址总线

    > 能够管理的内存（可寻址空间）

  + 控制总线

    > 发送相应控制信号

+ 外部总线

  

#### 17：串联系统和并联系统

##### 17.1、串联系统

+ 所有的子系统必须都可用，整个系统才可用

+ 系统可靠性公式

  $R = R_1 * R_2 * \ldots * R_n$

+ 系统失效率公式

  $\lambda = \lambda_1 + \lambda_2 + \ldots + \lambda_n$

##### 17.2、并联系统

+ 只要有一个子系统可用，整个系统就可用

+ 系统可靠性公式

  $R = 1 - (1 - R_1) * (1 - R_2) * \ldots * (1 - R_n)$

+ 系统失效率公式

  $\mu = 1 - R$
  
  

##### 17.3、模冗余系统


### 六：校验码

#### 18：循环校验码（CRC）

+ 数据串$1101011011$

+ 异或运算（$XOR/\bigoplus$）

  > 相同得0，不同得1

+ 多项式（Polynomical）

  $$\left(\sum_{i=1}^{j}{C_ix^i}\right) + 1 ,C = 0,1$$

  例如

  $$1 * x^6 + 0 * x^5 + 1 * x^4 + 0 * x^3 + 1 * x^2 + 1 * x^1 + 1 * x^0 \tag{9.1}$$

  可简写为

  $x^6 + x^4 + x^2 + x + 1 \tag{9.2}$

+ 除数

  CRC中用到的除数，正是由多项式$(9.1)$的各项系数组成，即$1010111$

  所以为了得到除数，只需要观察多项式列出系数即可

+ 在原数据串末端加$0$

  $0$的数量由多项式决定，具体来说，多项式的阶数是多少就加几个0，多项式$(9.2)$的阶数是6。

  可得数据串$1101011011000000$
  
+ 计算校验和

  + 将数据串第一个$1$与除数左对齐，按位进行异或操作。
  + 将未处理的数据搬下来作为新数据串，重复操作。
  + 直到所有数据都处理过为止。
  + 所得到的结果即是CRC校验和（长度为除数-1）






#### 19：海明校验码


#### 20：奇偶校验码








​                                                                                                                 